<<--------------------------------------------------------------------------------------------------------------------->>
<<---------------------------------------------------------性能优化----------------------------------------------------->>
<<--------------------------------------------------------------------------------------------------------------------->>

1、浏览器缓存策略
   对于浏览器端的缓存来讲，缓存的规则主要在HTTP协议头。
   Cache-Control与Expires
   Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。
   Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。
   Expires有可能存在时间不一致的问题。

   Etag（Entity Tag）是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。
   
   Last-Modified/ETag
   配置Last-Modified/ETag的情况下，浏览器再次访问同一URI的资源，还是会发送请求到服务器询问文件是否已经修改，
   如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；
   如果修改过那就整个数据重新发给浏览器；
   
   Cache-Control/Expires
   配置Last-Modified/ETag的情况下，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。
   两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。
   即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间或实体标识了。

   一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 
   当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，
   从而减少响应开销。

   有Last-Modified，为啥还要ETag
   HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：
   1）Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件是否被修改
   2）如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
   3）有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

   浏览器缓存刷新三种情况区别：
   1、在地址栏中输入网址后按回车或点击转到按钮
   浏览器以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存，从而减少了对浏览器的请求。
   所以，Expires，max-age标记只对这种方式有效。

   2、按F5或浏览器刷新按钮
   浏览器会在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存，它能够让 Last-Modified、ETag发挥效果，但是对Expires无效。

   3、按Ctrl+F5或按Ctrl并点击刷新按钮
   这种方式就是强制刷新，总会发起一个全新的请求，不使用任何缓存。